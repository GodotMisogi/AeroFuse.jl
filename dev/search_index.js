var documenterSearchIndex = {"docs":
[{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"EditURL = \"https://github.com/GodotMisogi/AeroFuse.jl/blob/main/docs/lit/howto.jl\"","category":"page"},{"location":"howto/#How-to-Guide","page":"How-to Guide","title":"How-to Guide","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"using AeroFuse # hide\nusing Plots # hide\ngr(dpi = 300) # hide\nusing LaTeXStrings # hide","category":"page"},{"location":"howto/#Airfoil-Geometry","page":"How-to Guide","title":"Airfoil Geometry","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"How to work with airfoil geometry.","category":"page"},{"location":"howto/#Import-Coordinates-File","page":"How-to Guide","title":"Import Coordinates File","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can specify the path consisting of the foil's coordinates to the read_foil function. The Selig format for the coordinates file is followed, in which a header for the name in the first line of the file with the coordinates following from the second line are required. A custom name can be provided by setting the optional name variable.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Airfoil coordinates file path\nfoilpath = string(@__DIR__, \"/misc/s1223.dat\")","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Note that, in this example, @__DIR__ points to the Julia REPL's current working directory. Use the correct local path for the coordinates on your computer.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Read coordinates file\nmy_foil = read_foil(\n    foilpath; # Path to the airfoil coordinates file\n    name = \"S1223\" # To overwrite name in header\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"plot(xlabel = L\"x\", ylabel = L\"y\", aspect_ratio = 1)\nplot!(my_foil)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"tip: Tip\nYou can also import airfoil coordinates from the internet.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Read coordinates from an internet address.\nonline_foil = read_foil(download(\"https://m-selig.ae.illinois.edu/ads/coord/s1210.dat\"))\n\nplot!(online_foil)","category":"page"},{"location":"howto/#Interpolate-and-Process-Coordinates","page":"How-to Guide","title":"Interpolate and Process Coordinates","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"A basic cosine interpolation functionality is provided for foils.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Cosine spacing with approx. 51 points on upper and lower surfaces each\ncos_foil = cosine_interpolation(my_foil, 51)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The upper and lower surfaces can be obtained by the following variety of functions.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Upper surface\nupper = upper_surface(my_foil)\n\n# Lower surface\nlower = lower_surface(my_foil)\n\n# Upper and lower surfaces\nupper, lower = split_surface(my_foil)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The camber-thickness distribution can be obtained as follows. It internally performs a cosine interpolation to standardize the x–coordinates for both surfaces; hence the number of points for the interpolation can be specified.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"xcamthick = camber_thickness(my_foil, 60)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can also do the inverse transformation.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"coords = camber_thickness_to_coordinates(xcamthick[:,1], xcamthick[:,2], xcamthick[:,3])","category":"page"},{"location":"howto/#Control-Surfaces","page":"How-to Guide","title":"Control Surfaces","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can (somewhat) mimic the behaviour of a control surface by specifying a deflection angle delta (in degrees, clockwise-positive convention) with the specification of the hinge location's x-coordinate normalized in 01 to the chord length.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"con_foil = control_surface(cos_foil; angle = 10., hinge = 0.75)\n\nplot!(con_foil)","category":"page"},{"location":"howto/#Doublet-Source-Aerodynamic-Analyses","page":"How-to Guide","title":"Doublet-Source Aerodynamic Analyses","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The solve_case method runs the analysis given a Foil containing the airfoil coordinates, a Uniform2D defining the boundary conditions, and an optional named specification for the number of panels. It returns a system which can be used to obtain the aerodynamic quantities of interest and post-processing.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Define freestream boundary conditions\nuniform = Uniform2D(1.0, 4.0)\n\n# Solve system\nsystem  = solve_case(\n    my_foil, # Foil\n    uniform; # Freestream condition\n    num_panels = 80\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The following functions compute the quantities of interest, such as the inviscid edge velocities, lift coefficient, and the sectional lift, moment, and pressure coefficients.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"cls, cms, cps = surface_coefficients(system);\nu_es   = surface_velocities(system)\ncl     = lift_coefficient(system)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"AeroFuse provides more helper functions for the panel geometry.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"panels   = system.surface_panels\npts      = collocation_point.(panels) # Collocation points\ntangents = tangent_vector.(panels)     # Tangents\nnormals  = normal_vector.(panels)      # Normals\nlocs     = panel_location.(panels);   # Upper or lower surface\nnothing #hide","category":"page"},{"location":"howto/#Wing-Geometry","page":"How-to Guide","title":"Wing Geometry","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"How to work with wing geometry.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"To define a wing, AeroFuse provides a Wing constructor based on the following parametrization. The named arguments correspond to the foil shapes, chord and span lengths, twist, dihedral and sweep angles.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"info: Info\n","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"A wing section consists of two foil profiles and their chord lengths and twist angles. Between them is their span length with associated leading-edge dihedral and sweep angles. So a general half-wing consisting of n sections will have n entries for spans b, dihedrals delta, sweeps Lambda, and n+1 entries for foils, chords c, and twists iota, for some n in mathbb N.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"(Image: )","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"airfoil = naca4((2,4,1,2))\nwing = Wing(\n    foils     = [ airfoil for i in 1:3 ],   # Foils\n    chords    = [0.4, 0.2, 0.1],  # Chord lengths\n    twists    = [0., 2., 5.],     # Twist angles (degrees)\n    spans     = [1.0, 0.1],       # Section span lengths\n    dihedrals = [0., 60.],        # Dihedral angles (degrees)\n    sweeps    = [0., 30.],        # Sweep angles (degrees)\n    w_sweep   = 0.25,             # Sweep angle location w.r.t.\n                                  # normalized chord lengths ∈ [0,1]\n    symmetry  = true,             # Whether wing is symmetric\n    # flip      = false           # Whether wing is flipped in x-z plane\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The symmetry Boolean argument specifies whether the geometry should be reflected in the x-z plane. The flip Boolean argument specifies whether the coordinates should be flipped in the x-z plane. The w_sweep argument specifies the chordwise-ratio of the sweep angles, e.g. 0. = leading edge sweep angle (default), 1. = trailing edge, 0.25 = quarter-chord.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The following \"getter\" functions provide quantities of interest such as chord lengths, spans, twist, dihedral, and sweep angles.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"foils(wing)\nchords(wing)\nspans(wing)\ntwists(wing)\ndihedrals(wing)\nsweeps(wing) # Leading-edge sweep angles\nsweeps(wing, 0.25) # Quarter-chord sweep angles\nsweeps(wing, 1.0) # Trailing-edge sweep angles","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can evaluate commonly defined properties such as the aspect ratio, projected area, etc., with the following functions.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"aspect_ratio(wing)\nprojected_area(wing)\nspan(wing)\ntaper_ratio(wing)\nmean_aerodynamic_chord(wing)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The mean aerodynamic center calculation merits discussion. Its calculation procedure is depicted in the following diagram:","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"(Image: )","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"mac25_w = mean_aerodynamic_center(wing) # 25% MAC by default\nmac40_w = mean_aerodynamic_center(wing, 0.4) # at 40% MAC","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can plot the wing with Plots.jl quite simply.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"plot(wing,\n    0.25; # Aerodynamic center location in terms of chord ratio plot\n    mac = true, # Optional named argument to disable aerodynamic center plot\n    zlim = (-0.5, 0.5) .* span(wing),\n    aspect_ratio = 1,\n    label = \"Wing\",\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"At 40% MAC","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"plot!(wing,\n    0.40; # 40% MAC\n    label = \"40% MAC\"\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"There is also a convenient function for pretty-printing information (using PrettyTables.jl), in which the first argument takes the Wing type and the second takes a name (as a String or Symbol).","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"print_info(wing, \"Wing\")","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"tip: Tip\nYou can use Accessors.jl to conveniently copy and modify properties of an existing object.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Import Accessors\nusing Accessors\n\n# Set only chords with other properties remaining identical.\nnew_wing = @set wing.chords = [0.4, 0.1, 0.05]","category":"page"},{"location":"howto/#Vortex-Lattice-Aerodynamic-Analyses","page":"How-to Guide","title":"Vortex Lattice Aerodynamic Analyses","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"How to run a generic aerodynamic analysis on a conventional aircraft configuration.","category":"page"},{"location":"howto/#Geometry","page":"How-to Guide","title":"Geometry","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"First we define the lifting surfaces. These can be a combination of Wing types constructed using the various methods available.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"info: Info\nSupport for fuselages and control surfaces is in progress.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Horizontal tail","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"htail = WingSection(\n    area       = 2.56 / 2,\n    aspect     = 6.25,\n    dihedral   = 0.0,\n    sweep      = 15.0,\n    taper      = 0.6,\n    root_twist = 0.0,\n    tip_twist  = 0.0,\n    root_foil  = naca4(0,0,1,2),\n    tip_foil   = naca4(0,0,0,9),\n    position   = [5., 0., -0.1],\n    angle      = 0.,\n    axis       = [0., 1., 0.],\n    symmetry   = true\n);\nnothing #hide","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Vertical tail","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"vtail = WingSection(\n    area       = 0.512 / 2,\n    aspect     = 1.25,\n    dihedral   = 0.0,\n    sweep      = 8.0,\n    taper      = 0.6,\n    root_twist = 0.0,\n    tip_twist  = 0.0,\n    root_foil  = naca4(0,0,0,9),\n    tip_foil   = naca4(0,0,0,9),\n    position   = [5., 0., 0.],\n    angle      = 90.,\n    axis       = [1., 0., 0.]\n)","category":"page"},{"location":"howto/#Meshing","page":"How-to Guide","title":"Meshing","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The WingMesh type takes a Wing type with a vector of integers consisting of the spanwise panel distribution corresponding to the number of sections, and an integer for the chordwise distribution.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Wing meshes\nwing_mesh = WingMesh(wing, [20,8], 10)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"tip: Tip\nOptionally ,the type of spanwise spacing can be specified by the keyword span_spacing and providing types Sine(), Cosine(), Uniform() or a vector of the combination with length corresponding to the number of sections. For example, if you have two spanwise sections and the wing is symmetric, then the total number of spanwise sections is four. So the spanwise spacing argument would be, for example, spanwise_spacing = [Uniform(), Cosine(), Cosine(), Uniform()]","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Horizontal tail\nhtail_mesh = WingMesh(htail, [10], 5;\n                      span_spacing = Cosine()) # Uniform(), Sine()\n\n# Vertical tail\nvtail_mesh = WingMesh(vtail, [10], 5); # Vertical tail\nnothing #hide","category":"page"},{"location":"howto/#Inviscid-Analysis","page":"How-to Guide","title":"Inviscid Analysis","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The inviscid 3D analysis uses a vortex lattice method. The WingMesh type allows you to generate horseshoe elements easily.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"wing_horsies = make_horseshoes(wing_mesh)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"note: Note\nYou can also generate vortex ring elements by calling make_vortex rings, but the aerodynamic analysis is slightly slower.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"For multiple lifting surfaces, it is most convenient to define a single vector consisting of all the components' horseshoes using ComponentArrays.jl.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"aircraft = ComponentVector(\n    wing = wing_horsies,\n    htail = make_horseshoes(htail_mesh),\n    vtail = make_horseshoes(vtail_mesh)\n);\nnothing #hide","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"To define boundary conditions, use the following Freestream type, which takes named arguments for angles of attack and sideslip (in degrees), and a quasi-steady rotation vector.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Define freestream conditions\nfs = Freestream(\n    alpha = 1.0,\n    beta  = 0.0,\n    omega = [0.,0.,0.]\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"To define reference values, use the following References type.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Define reference values\nrefs = References(\n    speed     = 150.0,\n    density   = 1.225,\n    viscosity = 1.5e-5,\n    area      = projected_area(wing),\n    span      = span(wing),\n    chord     = mean_aerodynamic_chord(wing),\n    location  = mean_aerodynamic_center(wing)\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The vortex lattice analysis can be executed with the vortex elements, freestream conditions, and reference values defined. An optional named argument is provided for enabling compressibility corrections at M  03 via the Prandtl-Glauert transformation.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Solve system\nsystem = solve_case(\n    aircraft, fs, refs;\n    compressible = true, # Compressibility corrections via Prandtl-Glauert transformation\n    print = true, # Prints the results for only the aircraft\n    print_components = true, # Prints the results for all components\n)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"If needed, you can access the relevant component influence matrix values and boundary conditions with the following attributes, e.g.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"system.influence_matrix[:wing] # Or :htail, :vtail\nsystem.influence_matrix[:wing, :htail];\n\nsystem.boundary_vector[:wing]","category":"page"},{"location":"howto/#Forces-and-Moments","page":"How-to Guide","title":"Forces and Moments","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The analysis computes the aerodynamic force coefficients C_mathbfF by surface pressure integration for nearfield forces. The aerodynamic moment coefficients C_mathbf M are calculated by computing the cross product of the moment arm of each control point from the reference point mathbf r_i - mathbf r_ref, i.e. (C_mathbfM)_i = (mathbf r_i - mathbf r_ref) times (C_mathbfF)_i","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"note: Note\nYou can specify the axis system for the nearfield forces, with choices of geometry, body, wind, or stability axes. The wind axes are used by default.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"# Compute dynamics\nax = Wind() # Body(), Stability(), Geometry()\n\n# Compute non-dimensional coefficients\nCFs, CMs = surface_coefficients(system; axes = ax)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can access the corresponding values of the components' by the name provided in the ComponentVector.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"CFs.wing","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Functions are available for directly retrieving the dimensionalized forces and moments.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Fs, Ms = surface_dynamics(system; axes = ax)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"A Trefftz plane integration is performed to compute farfield forces.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"note: Note\nThe farfield forces are usually more accurate compared to nearfield forces. (This is because the components do not interact as in the evaluation of the Biot-Savart integrals for the latter.)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"To obtain the nearfield coefficients of the components (in wind axes by definition):","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"nfs = nearfield_coefficients(system)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"Similarly for the farfield coefficients of the components.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"ffs = farfield_coefficients(system)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can access the values corresponding to the components by the name used in the ComponentArray construction.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"@show (nfs.wing, ffs.wing)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"To obtain the total nearfield and farfield force coefficients:","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"nf, ff = nearfield(system), farfield(system)","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"You can also print the relevant information as a pretty table, if necessary.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"print_coefficients(nfs.wing, ffs.wing, :wing)\nprint_coefficients(nf, ff, :aircraft)","category":"page"},{"location":"howto/#Aerodynamic-Stability-Analyses","page":"How-to Guide","title":"Aerodynamic Stability Analyses","text":"","category":"section"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"The derivatives of the aerodynamic coefficients with respect to the freestream values are obtained by automatic differentiation enabled by ForwardDiff. The following function evaluates the derivatives of the aerodynamic coefficients with respect to the freestream values. You can also optionally provide the axes for the reference frame of the coefficients.","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"dv_data = freestream_derivatives(\n    system,\n    print = true,  # Prints the results for only the aircraft\n    print_components = true,  # Prints the results for all components\n);\nnothing #hide","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"note: Note\nFor efficiency, instead of calling solve_case to compute the forces and then computing the derivatives, you can directly call:dvs = freestream_derivatives(\n          aircraft, fs, refs,\n          compressible     = true, # Compressibility option\n          print            = true, # Prints the results for only the aircraft\n          print_components = true, # Prints the results for all components\n      )","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"","category":"page"},{"location":"howto/","page":"How-to Guide","title":"How-to Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"structures/#Structures-API","page":"Structures API","title":"Structures API","text":"","category":"section"},{"location":"structures/#Beams-API","page":"Structures API","title":"Beams API","text":"","category":"section"},{"location":"structures/","page":"Structures API","title":"Structures API","text":"Modules = [AeroFuse.Beams]","category":"page"},{"location":"structures/#AeroFuse.Beams.Material-NTuple{4, Any}","page":"Structures API","title":"AeroFuse.Beams.Material","text":"Material(E, J, σ_max, ρ)\nMaterial(; elastic_modulus, shear_modulus, yield_stress, density)\n\nDefine a Material with positive, real elastic modulus E, shear modulus G, yield stress σ_max, and density ρ.\n\nThe default assignments for the named variables are set to the properties of aluminium?\n\nArguments\n\nelastic_modulus :: Real = 85e9: Elastic modulus.\nshear_modulus :: Real = 25e9: Shear modulus.\nyield_stress :: Real = 350e6: Yield stress.\ndensity :: Real = 1.6e3: Density.\n\n\n\n\n\n","category":"method"},{"location":"structures/#AeroFuse.Beams.Tube","page":"Structures API","title":"AeroFuse.Beams.Tube","text":"Tube(material :: Material, length, radius, thickness)\n\nDefine a hollow tube of fixed radius with a given material, length, and thickness.\n\n\n\n\n\n","category":"type"},{"location":"structures/#AeroFuse.Beams.tube_stiffness_matrix","page":"Structures API","title":"AeroFuse.Beams.tube_stiffness_matrix","text":"tube_stiffness_matrix(E, G, A, Iyy, Izz, J, L)\ntube_stiffness_matrix(E, G, A, Iyy, Izz, J, L, num)\ntube_stiffness_matrix(tube :: Tube)\ntube_stiffness_matrix(tube :: Vector{Tube})\ntube_stiffness_matrix(x :: Matrix{Real})\n\nGenerate the stiffness matrix using the properties of a tube. \n\nThe required properties are the elastic modulus E, shear modulus G, area A, moments of inertia about the y- and z- axes I_yy I_zz, polar moment of inertia J, length L. A composite stiffness matrix is generated with a specified number of elements.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#Geometry-API","page":"Geometry API","title":"Geometry API","text":"","category":"section"},{"location":"geometry/#Aircraft-Geometry-API","page":"Geometry API","title":"Aircraft Geometry API","text":"","category":"section"},{"location":"geometry/","page":"Geometry API","title":"Geometry API","text":"Modules = [AeroFuse.AircraftGeometry]","category":"page"},{"location":"geometry/#AeroFuse.AircraftGeometry.AbstractSpacing","page":"Geometry API","title":"AeroFuse.AircraftGeometry.AbstractSpacing","text":"An abstract type to define custom spacing distributions.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#AeroFuse.AircraftGeometry.Foil","page":"Geometry API","title":"AeroFuse.AircraftGeometry.Foil","text":"Foil(x, y, name = \"\")\nFoil(coordinates, name = \"\")\n\nStructure consisting of foil coordinates in 2 dimensions with an optional name. \n\nThe coordinates should be provided in counter-clockwise format, viz. from the trailing edge of the upper surface to the trailing edge of the lower surface.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#AeroFuse.AircraftGeometry.HyperEllipseFuselage-Tuple{}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.HyperEllipseFuselage","text":"HyperEllipseFuselage(;\n\nDefine a fuselage based on the following hyperelliptical-cylindrical parameterization.\n\nNose: Hyperellipse z(ξ) = (1 - ξ^a)^(1a)\n\nCabin: Cylindrical z(ξ) = 1\n\nRear: Hyperellipse z(ξ) = (1 - ξ^b)^(1b)\n\nArguments\n\nradius :: Real = 1.: Fuselage radius (m)\nlength :: Real = 6.: Fuselage length (m)\nx_a :: Real = 1.: Location of front of cabin as a ratio of fuselage length ∈ [0,1]\nx_b :: Real = 0.: Location of rear of cabin as a ratio of fuselage length ∈ [0,1]\nc_nose :: Real = 0.: Curvature of nose in terms of hyperellipse parameter a\nc_rear :: Real = 1.: Curvature of rear in terms of hyperellipse parameter b\nd_nose :: Real = 1.: \"Droop\" or \"rise\" of nose from front of cabin centerline (m)\nd_rear :: Real = 1.: \"Droop\" or \"rise\" of rear from rear of cabin centerline (m)\nposition :: Vector{Real} = zeros(3): Position (m)\nangle :: Real = 0.: Angle of rotation (degrees)\naxis :: Vector{Real} = [0, 1 ,0]: Axis of rotation, y-axis by default\naffine :: AffineMap = AffineMap(AngleAxis(deg2rad(angle), axis...), position): Affine mapping for the position and orientation via CoordinateTransformations.jl (overrides angle and axis if specified)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.Wing-Tuple{}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.Wing","text":"Wing(\n    chords, \n    foils :: Vector{Foil}, \n    twists, \n    spans, \n    dihedrals, \n    sweeps,\n    symmetry = false,\n    flip     = false,\n    position = zeros(3),\n    angle    = 0.,\n    axis     = [0.,1.,0.],\n)\n\nDefinition for a Wing consisting of N+1 Foils, their associated chord lengths c and twist angles ι, for N sections with span lengths b, dihedrals δ and leading-edge sweep angles Λ_LE, with all angles in degrees. Optionally, specify translation and a rotation in angle-axis representation for defining coordinates in a global axis system. Additionally, specify Boolean arguments for symmetry or reflecting in the x-z plane.\n\nArguments\n\nchords :: Vector{Real}: Chord lengths (m)\nfoils :: Vector{Foil} = fill(naca4(0,0,1,2), length(chords)): Foil shapes, default is NACA 0012.\nspans :: Vector{Real} = ones(length(chords) - 1) / (length(chords) - 1): Span lengths (m), default yields total span length 1.\ndihedrals :: Vector{Real} = zero(spans): Dihedral angles (deg), default is zero.\nsweeps :: Vector{Real} = zero(spans): Sweep angles (deg), default is zero.\nw_sweep :: Real = 0.: Chord ratio for sweep angle                          e.g., 0    = Leading-edge sweep,                                1    = Trailing-edge sweep,                               0.25 = Quarter-chord sweep\nsymmetry :: Bool = false: Symmetric in the x-z plane\nflip :: Bool = false: Flip coordinates in the x-z plane\nposition :: Vector{Real} = zeros(3): Position (m)\nangle :: Real = 0.: Angle of rotation (degrees)\naxis :: Vector{Real} = [0.,1.,0.]: Axis of rotation\naffine :: AffineMap = AffineMap(AngleAxis(deg2rad(angle), axis...), position): Affine mapping for the position and orientation via CoordinateTransformations.jl (overrides angle and axis if specified)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.WingMesh","page":"Geometry API","title":"AeroFuse.AircraftGeometry.WingMesh","text":"WingMesh(\n    wing :: AbstractWing, \n    n_span :: Vector{Integer}, n_chord :: Integer;\n    span_spacing :: AbstractSpacing = symmetric_spacing(wing)\n)\n\nDefine a container to generate meshes and panels for a given Wing with a specified distribution of number of spanwise panels, and a number of chordwise panels.\n\nOptionally a combination of AbstractSpacing types (Sine(), Cosine(), Uniform()) can be provided to the named argument span_spacing, either as a singleton or as a vector with length equal to the number of spanwise sections. By default, the combination is [Sine(), Cosine(), ..., Cosine()].\n\nFor surface coordinates, the wing mesh will have (nchord - 1) * 2 chordwise panels from TE-LE-TE and (nspan * 2) spanwise panels.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#AeroFuse.AircraftGeometry.WingSection-Tuple{}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.WingSection","text":"WingSection(; \n    area, aspect, taper\n    dihedral, sweep, w_sweep,\n    root_twist, tip_twist,\n    position, angle, axis,\n    symmetry, flip,\n    root_foil, tip_foil,\n    root_control, tip_control,\n)\n\nDefine a Wing in the x-z plane, with optional Boolean arguments for symmetry and flipping in the plane.\n\nArguments\n\narea :: Real = 1.: Area (m²)\naspect :: Real = 6.: Aspect ratio\ntaper :: Real = 1.: Taper ratio of tip to root chord\ndihedral :: Real = 1.: Dihedral angle (degrees)\nsweep :: Real = 0.: Sweep angle (degrees)\nw_sweep :: Real = 0.: Chord ratio for sweep angle                          e.g., 0    = Leading-edge sweep,                                1    = Trailing-edge sweep,                               0.25 = Quarter-chord sweep\nroot_twist :: Real = 0.: Twist angle at root (degrees)\ntip_twist :: Real = 0.: Twist angle at tip (degrees)\nroot_foil :: Foil = naca4((0,0,1,2)): Foil at root\ntip_foil :: Foil = root_foil: Foil at tip. Defaults to root foil.\nroot_control :: NTuple{2} = (0., 0.75): (Angle, hinge ratio) for adding a control surface at the root.\ntip_control :: NTuple{2} = root_control: (Angle, hinge ratio) for adding a control surface at the tip. Defaults to root control's settings.\nsymmetry :: Bool = false: Symmetric in the x-z plane\nflip :: Bool = false: Flip coordinates in the x-z plane\nposition :: Vector{Real} = zeros(3): Position (m)\nangle :: Real = 0.: Angle of rotation (degrees)\naxis :: Vector{Real} = [0.,1.,0.]: Axis of rotation\naffine :: AffineMap = AffineMap(AngleAxis(deg2rad(angle), axis...), position): Affine mapping for the position and orientation via CoordinateTransformations.jl (overrides angle and axis if specified)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.affine-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.affine","text":"affine(\n    foil :: Foil, \n    angle, vector\n)\n\nPerform an affine transformation on the coordinates of a Foil by a 2-dimensional vector mathbf v and angle θ.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.arc_length-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.arc_length","text":"arc_length(foil :: Foil)\n\nCompute the arc-length of a Foil.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.aspect_ratio-Tuple{Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.aspect_ratio","text":"aspect_ratio(wing :: AbstractWing)\n\nCompute the aspect ratio of an AbstractWing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber-Tuple{Foil, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber","text":"camber(foil :: Foil, x_by_c)\n\nObtain the camber value of a Foil at a specified (xc).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_CST","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_CST","text":"camber_CST(α_c, α_t,\n           Δz :: Real,\n           n :: Integer = 40)\n\nDefine a cosine-spaced foil with 2n points using the Class Shape Transformation method on a Bernstein polynomial basis for the camber and thickness coordinates.\n\nThe foil is defined by arrays of coefficients (α_c α_t) for the upper and lower surfaces, trailing-edge spacing values (Δz_uΔz_l), and a coefficient for the leading edge modifications at the nose.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_coordinates","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_coordinates","text":"camber_coordinates(wing :: WingMesh, n_span = wing.num_span, n_chord = wing.num_chord)\n\nGenerate the camber coordinates of a WingMesh with default spanwise n_s and chordwise n_c panel distributions from the mesh.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_line","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_line","text":"camber_line(foil :: Foil, n :: Integer = 40)\n\nGet the camber line of a Foil. Optionally specify the number of points for linear interpolation, default is 40.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_panels-Tuple{WingMesh}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_panels","text":"camber_panels(wing_mesh :: WingMesh)\n\nGenerate the camber mesh as a matrix of Panel3D from a WingMesh.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_thickness","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_thickness","text":"camber_thickness(foil :: Foil, num :: Integer)\n\nCompute the camber-thickness distribution of a Foil with cosine interpolation. Optionally specify the number of points for interpolation, default is 40.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_thickness-Tuple{Wing, Integer}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_thickness","text":"camber_thickness(wing :: Wing, num :: Integer)\n\nCompute the camber-thickness distribution at each spanwise intersection of a Wing. A num must be specified to interpolate the internal Foil coordinates, which affects the accuracy of (tc)ₘₐₓ accordingly.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.camber_thickness_to_CST-Tuple{Any, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.camber_thickness_to_CST","text":"camber_thickness_to_CST(coords, num_dvs)\n\nConvert camber-thickness coordinates to a specified number of Bernstein polynomial coefficients under a Class Shape Transformation by performing a least-squares solution.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.chord_coordinates","page":"Geometry API","title":"AeroFuse.AircraftGeometry.chord_coordinates","text":"chord_coordinates(wing :: WingMesh, n_span = wing.num_span, n_chord = wing.num_chord)\n\nGenerate the chord coordinates of a WingMesh with default spanwise n_s and chordwise n_c panel distributions from the mesh.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.chord_panels-Tuple{WingMesh}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.chord_panels","text":"chord_panels(wing_mesh :: WingMesh)\n\nGenerate the chord mesh as a matrix of Panel3D from a WingMesh.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.control_surface-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.control_surface","text":"control_surface(foil :: Foil, δ, xc_hinge)\ncontrol_surface(foil :: Foil; angle, hinge)\n\nModify a Foil to mimic a control surface by specifying a deflection angle δ(in degrees, clockwise-positive convention) and a normalized hingex-coordinate∈ [0,1]in terms of the chord length. A constructor with named argumentsangle, hinge` is provided for convenience.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.coordinates","page":"Geometry API","title":"AeroFuse.AircraftGeometry.coordinates","text":"wetted_area(fuse :: HyperEllipseFuselage, t)\n\nGet the coordinates of a HyperEllipseFuselage given the parameter distribution t. Note that the distribution must have endpoints 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.coordinates-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.coordinates","text":"coordinates(foil :: Foil)\n\nGenerate the array of Foil coordinates. \n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.coordinates_to_CST-Tuple{Any, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.coordinates_to_CST","text":"coordinates_to_CST(coords, num_dvs)\n\nConvert coordinates to a specified number of Bernstein polynomial coefficients under a Class Shape Transformation by performing a least-squares solution.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.cosine_interpolation","page":"Geometry API","title":"AeroFuse.AircraftGeometry.cosine_interpolation","text":"cosine_interpolation(foil :: Foil, n :: Integer = 40)\n\nInterpolate a Foil profile's coordinates to a cosine by projecting the x-coordinates of a circle onto the geometry with 2n points.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.interpolate-Tuple{Foil, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.interpolate","text":"interpolate(foil :: Foil, xs)\n\nLinearly interpolate the coordinates of a Foil to a given x  01 distribution.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.kulfan_CST","page":"Geometry API","title":"AeroFuse.AircraftGeometry.kulfan_CST","text":"kulfan_CST(alpha_u, alpha_l,\n           (Δz_u, Δz_l) = (0., 0.),\n           (LE_u, LE_l) = (0., 0.),\n           n            = 40)\n\nDefine a cosine-spaced foil with 2n points using the Class Shape Transformation method on a Bernstein polynomial basis for the upper and lower coordinates.\n\nThe foil is defined by arrays of coefficients (α_u α_l) for the upper and lower surfaces (not necessarily of the same lengths), trailing-edge displacement values (Δz_u Δz_l), and coefficients for leading edge modifications on the upper and lower surfaces at the nose.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.leading_edge-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.leading_edge","text":"leading_edge(wing :: Wing)\n\nCompute the leading edge coordinates of a Wing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.leading_edge_index-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.leading_edge_index","text":"leading_edge_index(foil :: Foil)\n\nGet the index of the leading edge of a Foil. This will be the index of the point with the minimum x-coordinate.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.lower_surface-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.lower_surface","text":"lower_surface(foil :: Foil)\n\nGet the lower surface coordinates of a Foil from leading to trailing edge.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.maximum_thickness_to_chord","page":"Geometry API","title":"AeroFuse.AircraftGeometry.maximum_thickness_to_chord","text":"maximum_thickness_to_chord(foil :: Foil, num :: Integer)\n\nCompute the maximum thickness-to-chord ratio (tc)ₘₐₓ and its location (xc) of a Foil. Returned as the pair (xc (tc)ₘₐₓ).\n\nA num must be specified to interpolate the Foil coordinates, which affects the accuracy of (tc)ₘₐₓ accordingly, default is 40.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.maximum_thickness_to_chord-Tuple{Wing, Integer}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.maximum_thickness_to_chord","text":"maximum_thickness_to_chord(wing :: Wing, num :: Integer)\n\nCompute the maximum thickness-to-chord ratios (tc)ₘₐₓ and their locations (xc) at each spanwise intersection of a Wing. \n\nReturns an array of pairs (xc)(tc)ₘₐₓ, in which the first entry of each pair is the location (normalized to the local chord length at the spanwise intersection) and the corresponding maximum thickness-to-chord ratio at the intersection.\n\nA num must be specified to interpolate the internal Foil coordinates, which affects the accuracy of (tc)ₘₐₓ accordingly.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.mean_aerodynamic_center","page":"Geometry API","title":"AeroFuse.AircraftGeometry.mean_aerodynamic_center","text":"mean_aerodynamic_center(wing :: Wing, \n    factor = 0.25; \n    symmetry = wing.symmetry, \n    flip = wing.flip\n)\n\nCompute the mean aerodynamic center of a Wing. By default, the factor is assumed to be at 25% from the leading edge, which can be adjusted. Similarly, options are provided to account for symmetry or to flip the location in the x-z plane.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.mean_aerodynamic_chord-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.mean_aerodynamic_chord","text":"mean_aerodynamic_chord(wing :: Wing)\n\nCompute the mean aerodynamic chord of a Wing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.naca4","page":"Geometry API","title":"AeroFuse.AircraftGeometry.naca4","text":"naca4(digits :: NTuple{4, <: Real}, n :: Integer = 40; sharp_TE :: Bool)\nnaca4(a, b, c, d, n :: Integer = 40; sharp_TE :: Bool)\n\nGenerate a Foil of a NACA 4-digit series profile with the specified digits, number of points (40 by default), and a named option to specify a sharp or blunt trailing edge. \n\nRefer to the formula for the digits here: http://airfoiltools.com/airfoil/naca4digit\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.naca4_coordinates-Tuple{NTuple{4, var\"#s21\"} where var\"#s21\"<:Real, Integer, Bool}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.naca4_coordinates","text":"naca4_coordinates(digits :: NTuple{4, <: Real}, n :: Integer, sharp_TE :: Bool)\n\nGenerate the coordinates of a NACA 4-digit series profile with a specified number of points, and a Boolean flag to specify a sharp or blunt trailing edge.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.projected_area-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.projected_area","text":"projected_area(wing :: Wing)\n\nCompute the projected area (onto the spanwise plane) of a Wing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.properties-Tuple{AbstractWing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.properties","text":"properties(wing :: AbstractWing)\n\nCompute the generic properties of interest (span, area, etc.) of an AbstractWing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.read_foil-Tuple{String}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.read_foil","text":"read_foil(\n    path :: String; \n    header = true; \n    name = \"\"\n)\n\nGenerate a Foil from a file consisting of 2D coordinates with named arguments to skip the header (first line of the file) or assign a name.\n\nBy default, the header is assumed to exist and should contain the airfoil name, which is assigned to the name of the Foil.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.reflect-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.reflect","text":"reflect(foil :: Foil)\n\nReflect the y-coordinates of a Foil about the y = 0 line.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.rotate-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.rotate","text":"rotate(foil :: Foil; \n    angle, \n    center = zeros(2)\n)\n\nRotate the coordinates of a Foil about a 2-dimensional point (default is origin) by the angle θ (in degrees).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.scale-Tuple{Foil, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.scale","text":"scale(foil :: Foil, scale)\n\nScale the coordinates of a Foil to a scaling value.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.span-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.span","text":"span(wing :: Wing)\n\nCompute the planform span of a Wing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.split_surface-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.split_surface","text":"split_surface(foil :: Foil)\n\nSplit the Foil coordinates into upper and lower surfaces.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.surface_coordinates","page":"Geometry API","title":"AeroFuse.AircraftGeometry.surface_coordinates","text":"surface_coordinates(wing :: WingMesh, n_span = wing.num_span, n_chord = wing.num_chord)\n\nGenerate the surface coordinates of a WingMesh with default spanwise n_s and chordwise n_c panel distributions from the mesh.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.surface_panels","page":"Geometry API","title":"AeroFuse.AircraftGeometry.surface_panels","text":"surface_panels(\n    wing_mesh :: WingMesh, \n    n_s = wing_mesh.num_span, \n    n_c = length(first(foils(wing_mesh.surface))).x\n)\n\nGenerate the surface panel distribution from a WingMesh with the default spanwise n_s panel distribution from the mesh and the chordwise panel n_c distribution from the number of points defining the root airfoil.\n\nIn case of strange results, provide a higher number of chordwise panels to represent the airfoils more accurately\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.sweeps","page":"Geometry API","title":"AeroFuse.AircraftGeometry.sweeps","text":"sweeps(wing :: AbstractWing, w = 0.)\n\nObtain the sweep angles (in radians) at the corresponding normalized chord length ratio w  01.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.taper_ratio-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.taper_ratio","text":"taper_ratio(wing :: Wing)\n\nCompute the taper ratio of a Wing, defined as the tip chord length divided by the root chord length, independent of the number of sections.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.thickness_line","page":"Geometry API","title":"AeroFuse.AircraftGeometry.thickness_line","text":"thickness_line(foil :: Foil, n :: Integer = 40)\n\nGet the thickness line of a Foil. Optionally specify the number of points for linear interpolation, default is 40.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.AircraftGeometry.trailing_edge-Tuple{Wing}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.trailing_edge","text":"trailing_edge(wing :: Wing)\n\nCompute the trailing edge coordinates of a Wing.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.translate-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.translate","text":"translate(foil :: Foil, vector)\n\nTranslate the coordinates of a Foil by a 2-dimensional vector mathbf v.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.upper_surface-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.upper_surface","text":"upper_surface(foil :: Foil)\n\nGet the upper surface coordinates of a Foil from leading to trailing edge.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.volume-Tuple{HyperEllipseFuselage, Any}","page":"Geometry API","title":"AeroFuse.AircraftGeometry.volume","text":"volume(fuse :: HyperEllipseFuselage, ts)\n\nCompute the volume of a HyperEllipseFuselage given the parameter distribution t. Note that the distribution must have endpoints 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.AircraftGeometry.wetted_area_ratio","page":"Geometry API","title":"AeroFuse.AircraftGeometry.wetted_area_ratio","text":"wetted_area_ratio(\n    wing_mesh :: WingMesh, \n    n_s = wing_mesh.num_span, \n    n_c = length(first(foils(wing_mesh.surface))).x\n)\n\nDetermine the wetted area ratio S_wetS of a WingMesh by calculating the ratio of the total area of the surface panels to the projected area of the Wing.\n\nThe wetted area ratio should be slightly above 2 for thin airfoils.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.PanelGeometry.make_panels-Tuple{Foil}","page":"Geometry API","title":"AeroFuse.PanelGeometry.make_panels","text":"make_panels(foil :: Foil)\nmake_panels(foil :: Foil, n :: Integer)\n\nGenerate a vector of Panel2Ds from a Foil, additionally with cosine interpolation using (approximately) n points if provided.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.wetted_area","page":"Geometry API","title":"AeroFuse.PanelGeometry.wetted_area","text":"wetted_area(\n    wing_mesh :: WingMesh, \n    n_s = wing_mesh.num_span, \n    n_c = length(first(foils(wing_mesh.surface))).x\n)\n\nDetermine the wetted area S_wet of a WingMesh by calculating the total area of the surface panels.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.PanelGeometry.wetted_area-Tuple{HyperEllipseFuselage, Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.wetted_area","text":"wetted_area(fuse :: HyperEllipseFuselage, t)\n\nCompute the wetted area of a HyperEllipseFuselage given the parameter distribution t. Note that the distribution must have endpoints 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Panel-Geometry-API","page":"Geometry API","title":"Panel Geometry API","text":"","category":"section"},{"location":"geometry/","page":"Geometry API","title":"Geometry API","text":"Modules = [AeroFuse.PanelGeometry]","category":"page"},{"location":"geometry/#AeroFuse.PanelGeometry.Panel3D","page":"Geometry API","title":"AeroFuse.PanelGeometry.Panel3D","text":"Panel3D(p1, p2, p3, p4)\n\nFour Cartesian coordinates p1, p2, p3, p4 representing corners of a panel in 3 dimensions. The following commutative diagram (math joke) depicts the order:\n\nz → y\n↓\nx\n        p1 —→— p4\n        |       |\n        ↓       ↓\n        |       |\n        p2 —→— p3\n\n\n\n\n\n","category":"type"},{"location":"geometry/#AeroFuse.PanelGeometry.get_transformation","page":"Geometry API","title":"AeroFuse.PanelGeometry.get_transformation","text":"get_transformation(panel :: AbstractPanel3D)\n\nGenerate the mapping to transform a point from global coordinates to an AbstractPanel3D's local coordinate system.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#AeroFuse.PanelGeometry.make_panels-Tuple{Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.make_panels","text":"make_panels(xyzs)\n\nConvert an array of coordinates corresponding to a wing, ordered from root to tip and leading-edge to trailing-edge, into panels.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.midpoint-Tuple{AbstractPanel3D}","page":"Geometry API","title":"AeroFuse.PanelGeometry.midpoint","text":"midpoint(panel :: AbstractPanel3D)\n\nCompute the midpoint of an AbstractPanel3D.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.normal_vector-Tuple{AbstractPanel3D}","page":"Geometry API","title":"AeroFuse.PanelGeometry.normal_vector","text":"normal_vector(panel :: Panel3D)\n\nCompute the normal vector of an AbstractPanel3D.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.panel_area-Tuple{Panel3D}","page":"Geometry API","title":"AeroFuse.PanelGeometry.panel_area","text":"panel_area(panel :: AbstractPanel3D)\n\nCompute the area of a planar quadrilateral 3D panel.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.panel_coordinates-Tuple{AbstractPanel3D}","page":"Geometry API","title":"AeroFuse.PanelGeometry.panel_coordinates","text":"panel_coordinates(panel :: Panel3D)\n\nCompute the coordinates of a Panel3D.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.reflect_xz-Tuple{Panel3D}","page":"Geometry API","title":"AeroFuse.PanelGeometry.reflect_xz","text":"reflect_xz(panel :: Panel3D)\n\nReflect a Panel3D with respect to the x-z plane of its reference coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.transform-Tuple{Panel3D, Any, Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.transform","text":"transform(panel :: Panel3D, rotation, translation)\n\nPerform an affine transformation on the coordinates of a Panel3D given a rotation matrix and translation vector.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.transform_normal-Tuple{Panel3D, Any, Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.transform_normal","text":"transform_normal(panel :: Panel3D, h_l, g_l)\n\nTransform the normal vector n₀ of a Panel3D about the hinge axis ĥₗ by the control gain gₗ.\n\nThe transformation is the following: nₗ = gₗ hₗ  n₀ (Flight Vehicle Aerodynamics, M. Drela, Eq. 6.36).\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.wake_panel-Tuple{DenseArray{<:AbstractPanel3D}, Any, Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.wake_panel","text":"wake_panel(panels :: DenseArray{<: AbstractPanel3D}, bound, U)\n\nCalculate required transformation from the global coordinate system to an to an AbstractPanel3D's local coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"geometry/#AeroFuse.PanelGeometry.wetted_area-Tuple{Any}","page":"Geometry API","title":"AeroFuse.PanelGeometry.wetted_area","text":"wetted_area(panels :: Array{Panel3D})\n\nCompute the total wetted area by summing the areas of an array of Panel3D.\n\n\n\n\n\n","category":"method"},{"location":"theory/","page":"Theory","title":"Theory","text":"EditURL = \"https://github.com/GodotMisogi/AeroFuse.jl/blob/main/docs/lit/theory.jl\"","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The following theory described is meant to be minimal, with mainly the equations presented for reference when reading the code.","category":"page"},{"location":"theory/#Geometry","page":"Theory","title":"Geometry","text":"","category":"section"},{"location":"theory/#Wing-Parametrization","page":"Theory","title":"Wing Parametrization","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"A half-wing is defined in terms of a nested trapezoid. A single trapezoid is called a section. A section consists of two foil profiles, and their associated chord lengths and twist angles. Between them is their span length with associated leading-edge dihedral and sweep angles. So a general half-wing consisting of n sections will have n entries for foils, chords, and twists, and n - 1 entries for spans, dihedrals, sweeps for some n in mathbb N. The following illustration should help visualize the concept.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/#Aerodynamics","page":"Theory","title":"Aerodynamics","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The aerodynamic analyses in AeroFuse mainly utilize potential flow theory and solve problems using a boundary element method. This essentially is the following Laplace equation problem with the following Robin (?) boundary conditions:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"nabla^2 phi = 0 quad mathbf V equiv nabla phi cdot hatmathbf n = 0 quad lim_mathbf r to infty phi(mathbf r) to 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nImplementations of viscous-inviscid coupled analyses for drag prediction (á là XFOIL) are in progress.","category":"page"},{"location":"theory/#Doublet-Source-Panel-Method","page":"Theory","title":"Doublet-Source Panel Method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The doublet-source panel method predicts inviscid, incompressible, irrotational, isentropic external flow over surfaces in 2 dimensions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Source and doublet singularities are placed on the surface, and boundary conditions are imposed on their induced velocity to obtain a well-posed problem. The induced velocity is evaluated by the corresponding free-field Green function for each singularity.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The velocities are added to obtain the total induced velocity at a point mathbf r.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Vortex-Lattice-Method","page":"Theory","title":"Vortex Lattice Method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The vortex lattice method predicts inviscid, incompressible, irrotational, isentropic external flow over \"thin\" surfaces in 3 dimensions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Vortex filaments are placed on the surface, and boundary conditions are imposed on their induced velocity to obtain a well-posed problem. The induced velocity is evaluated by the Biot-Savart integral for a vortex line of length ell with a constant circulation strength Gamma.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbf V(mathbf r mathbf r) = fracGamma4pi int_0^ell fracdboldsymbolell times (mathbf r - mathbf r)mathbf r - mathbf r^3","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The vortices can be set up in various configurations consisting of bound or semi-infinite filaments, commonly in the form of horseshoes or vortex rings.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Horseshoe elements: These are defined by a finite bound leg and two semi-infinite trailing legs. AeroFuse encodes this information in the Horseshoe type.\nVortex rings: These are defined by four bound legs. AeroFuse encodes this information in the VortexRing type.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A quasi-steady freestream condition with velocity mathbf U and rotation boldsymbolOmega (in the body's frame) defines an external flow. The induced velocity at a point is given by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbf V_infty(mathbf r) = - (mathbf U + boldsymbolOmega times mathbf r)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The velocities are added to obtain the total induced velocity at a point mathbf r.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbf V(mathbf r) = sum_i fracGamma_i4pi int_0^ell_i fracdboldsymbolell_i times (mathbf r - mathbf r_i)mathbf r - mathbf r_i^3 + mathbf V_infty(mathbf r)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Imposing the Neumann boundary condition mathbf V cdot hatmathbf n = 0 defines the problem. The construction, in essence, fundamentally results in the following linear system to be solved:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbf A boldsymbolGamma = -V_infty cdot hatmathbf n_i _i = 1 ldots N","category":"page"},{"location":"theory/#Compressibility-Corrections","page":"Theory","title":"Compressibility Corrections","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The following Prandtl-Glauert equation, represented in wind axes, is applied for a weakly compressible flow problem (03 leq M_infty leq 07).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beta_PG^2fracpartial^2phipartial x^2 + fracpartial^2phipartial y^2 + fracpartial^2phipartial z^2 = 0 quad beta_PG^2 = left(1 - M_infty^2right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Prandtl-Glauert transformation phi(xyz beta_PG) to barphi(bar x bar y bar z) converts this equation into an equivalent incompressible flow problem in a transformed geometric space. This \"bar\" map scales the coordinates (bar xbar y bar z) = (xbeta_PG y beta_PG z) and the potential barphi = beta_PG^2 phi in sequence. Hence the transformed equation satisfies the Laplace equation with the Neumann boundary condition:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n    barnabla^2 barphi  = 0 \n    barmathbf V cdot hatbarmathbf n  = 0\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where barnabla is differentiation with respect to the transformed coordinates and hatbarmathbf n = (beta_PG hat n_x hat n_y hat n_z) which can be proved by computing the appropriate cross product.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As the circulation is a scalar (hence invariant of the coordinate transformation but not the potential scaling), the inverse is also readily derived.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n    Gamma  = int mathbf V cdot dboldsymbolell = int nablaphi cdot dboldsymbolell \n    barGamma  = int barmathbf V cdot dbar boldsymbolell = intbarnablabarphi cdot dbarboldsymbolell \n    implies Gamma  = barGamma  beta_PG^2\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Hence the solution of the resultant incompressible system in transformed coordinates provides the necessary quantities of interest for calculating the dynamics.","category":"page"},{"location":"theory/#Structures","page":"Theory","title":"Structures","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The structural analyses in AeroFuse utilize linear finite-element methods.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Particularly, a 2-dimensional beam element model has been implemented following the standard formulation using cubic Hermite shape functions based on Euler-Bernoulli beam theory. These are embedded into a 3-dimensional local coordinate system in the vortex lattice method without loss of generality.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The linear system consisting of the stiffness matrix mathbf K and load vector mathbf f are solved to obtain the displacement vector boldsymboldelta.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbf K boldsymboldelta = mathbf f","category":"page"},{"location":"theory/#Aeroelasticity","page":"Theory","title":"Aeroelasticity","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The vortex lattice method and beam element model are combined into a coupled system to perform static aeroelastic analyses. The analysis is made nonlinear via promotion of the angle of attack alpha to a variable by specifying the load factor n with a given weight W at fixed sideslip angle beta.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Define mathbf x = boldsymbolGamma boldsymboldelta alpha as the state vector satisfying the residual equations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n    mathcal R_A(mathbf x)  = mathbf A(boldsymboldelta) boldsymbolGamma - mathbf V_infty(alpha) cdot mathbf n_i(boldsymboldelta)_i = 1ldots N \n    mathcal R_S(mathbf x)  = mathbf K boldsymboldelta - mathbf f(boldsymboldelta boldsymbolGamma alpha) \n    mathcal R_L(mathbf x)  = L(boldsymboldelta boldsymbolGamma alpha) - n W \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where the lift L is obtained by transforming forces computed via the Kutta-Jowkowski theorem into wind axes.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"D Y L = mathbf R_B^W(alpha beta)left(sum_i = 1^N rho mathbf V_i times  boldsymbolGamma_i boldsymbol ell_i(boldsymboldelta)right)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the structural load vector mathbf f is obtained from conservative and consistent load averaging of the Kutta-Jowkowski forces in geometric axes.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Mark Drela. Flight Vehicle Aerodynamics. MIT Press, 2014.\nJoseph Katz and Allen Plotkin. Low-Speed Aerodynamics, Second Edition. Cambridge University Press, 2001.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"aerodynamics/#Aerodynamics-API","page":"Aerodynamics API","title":"Aerodynamics API","text":"","category":"section"},{"location":"aerodynamics/#Doublet-Source-Panel-API","page":"Aerodynamics API","title":"Doublet-Source Panel API","text":"","category":"section"},{"location":"aerodynamics/","page":"Aerodynamics API","title":"Aerodynamics API","text":"Modules = [AeroFuse.DoubletSource]","category":"page"},{"location":"aerodynamics/#AeroFuse.DoubletSource.boundary_vector-Tuple{Any, Any}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.boundary_vector","text":"boundary_vector(panels, u)\n\nCreate the vector for the boundary condition of the problem given an array of Panel2Ds and velocity u.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.doublet_matrix-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T<:AbstractPanel2D","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.doublet_matrix","text":"doublet_matrix(panels_1, panels_2)\n\nCreate the matrix of doublet potential influence coefficients between pairs of panels₁ and panels₂.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.influence_matrix-Tuple{Any, AbstractPanel2D}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.influence_matrix","text":"influence_matrix(panels, wake_panel :: AbstractPanel2D)\n\nAssemble the Aerodynamic Influence Coefficient matrix consisting of the doublet matrix, wake vector, Kutta condition given Panel2Ds and the wake panel.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.kutta_condition-Tuple{AbstractVector{<:AbstractPanel2D}}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.kutta_condition","text":"kutta_condition(panels)\n\nCreate the vector describing Morino's Kutta condition given Panel2Ds.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.solve_linear-Tuple{AbstractArray{<:AbstractPanel2D}, Any, Any}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.solve_linear","text":"solve_linear(panels, u, wakes)\n\nSolve the linear aerodynamic system given the array of Panel2Ds, a velocity vec U, a vector of wake Panel2Ds, and an optional named bound for the length of the wake.\n\nThe system of equations Aφ = vecU  n - Bσ is solved, where A is the doublet influence coefficient matrix, φ is the vector of doublet strengths, B is the source influence coefficient matrix, and σ is the vector of source strengths.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.solve_linear-Tuple{Any, Any, Any, Any, Bool}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.solve_linear","text":"solve_linear(panels, u, sources, bound)\n\nSolve the system of equations AICφ = vecU  n - Bσ condition given the array of Panel2Ds, a velocity vec U, a condition whether to disable source terms (σ = 0), and an optional named bound for the length of the wake.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.source_matrix-Tuple{Any, Any}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.source_matrix","text":"doublet_matrix(panels_1, panels_2)\n\nCreate the matrix of source potential influence coefficients between two arrays of Panel2Ds.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.source_strengths-Tuple{Any, Any}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.source_strengths","text":"source_strengths(panels, freestream)\n\nCreate the vector of source strengths for the Dirichlet boundary condition σ = vec U_infty  n given Panel2Ds and a Uniform2D.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.DoubletSource.wake_vector-Tuple{AbstractPanel2D, Any}","page":"Aerodynamics API","title":"AeroFuse.DoubletSource.wake_vector","text":"wake_vector(woke_panel :: AbstractPanel2D, panels)\n\nCreate the vector of doublet potential influence coefficients from the wake on the panels given the wake panel and the array of Panel2Ds.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.surface_velocities-Tuple{Any, Any, Any, Any, Bool}","page":"Aerodynamics API","title":"AeroFuse.surface_velocities","text":"surface_velocities(panels, φs, u, sources :: Bool)\n\nCompute the surface speeds and panel distances given the array of Panel2Ds, their associated doublet strengths φs, the velocity u, and a condition whether to disable source terms (σ = 0).\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#Vortex-Lattice-API","page":"Aerodynamics API","title":"Vortex Lattice API","text":"","category":"section"},{"location":"aerodynamics/","page":"Aerodynamics API","title":"Aerodynamics API","text":"Modules = [AeroFuse.VortexLattice]","category":"page"},{"location":"aerodynamics/#AeroFuse.VortexLattice.Horseshoe","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.Horseshoe","text":"Horseshoe(r1, r2, rc, normal, chord)\n\nDefine a horseshoe vortex with a start and endpoints r₁ r₂ for the bound leg, a collocation point r, a normal vector n, and a finite core size.\n\nThe finite core setup is not implemented for now.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/#AeroFuse.VortexLattice.References","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.References","text":"References(V, ρ, μ, S, b, c, r)\nReferences(; \n    speed, density, viscosity,\n    sound_speed, area, span, \n    chord, location\n)\n\nDefine reference values with speed V, density ρ, dynamic viscosity μ, area S, span b, chord c, location r for a vortex lattice analysis. A constructor with named arguments is provided for convenience:\n\nArguments\n\nspeed       :: Real         = 1.: Speed (m/s)\ndensity     :: Real         = 1.225: Density (m)\nviscosity   :: Real         = 1.5e-5: Dynamic viscosity (kg/(m ⋅ s))\nsound_speed :: Real         = 330.: Speed of sound (m/s)\narea        :: Real         = 1.: Area (m²)\nspan        :: Real         = 1.: Span length (m)\nchord       :: Real         = 1.: Chord length (m)\nlocation    :: Vector{Real} = [0,0,0]: Position (m)\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/#AeroFuse.VortexLattice.VortexLatticeSystem","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.VortexLatticeSystem","text":"VortexLatticeSystem\n\nA system consisting of the relevant variables for a vortex lattice analysis for post-processing.\n\nArguments\n\nThe accessible fields are:\n\nvortices:  The array of vortices, presently of AbstractVortex types.\ncirculations: The circulation strengths of the vortices obtained by solving the linear system.\ninfluence_matrix: The influence matrix of the linear system.\nboundary_vector: The boundary condition corresponding to the right-hand-side of the linear system.\nfreestream :: Freestream: The freestream conditions.\nreference :: References: The reference values.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/#AeroFuse.VortexLattice.VortexLatticeSystem-2","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.VortexLatticeSystem","text":"VortexLatticeSystem(\n    aircraft, \n    fs :: Freestream, \n    refs :: References, \n    compressible = false, \n    axes = Geometry()\n)\n\nConstruct a VortexLatticeSystem for analyzing inviscid aerodynamics of an aircraft (must be a ComponentArray of Horseshoes or VortexRings) with Freestream conditions and References for non-dimensionalization. Options are provided for compressibility corrections via the Prandtl-Glauert transformation (false by default) and axis system for computing velocities and forces (Geometry by default).\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/#AeroFuse.VortexLattice.VortexRing","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.VortexRing","text":"VortexRing(r1, r2, r3, r4, r_c, n̂, ε)\n\nA vortex ring consisting of four points r_i i = 14, a collocation point r_c, a normal vector n, and a core size ε. The following convention is adopted:\n\n    r1 —front leg→ r4\n    |               |\nleft leg       right leg\n    ↓               ↓\n    r2 —back leg-→ r3\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/#AeroFuse.VortexLattice.bound_leg_center-Tuple{Horseshoe}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.bound_leg_center","text":"bound_leg_center(hs :: Horseshoe)\n\nCompute the midpoint of the bound leg of a Horseshoe.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.bound_leg_vector-Tuple{Horseshoe}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.bound_leg_vector","text":"bound_leg_vector(hs :: Horseshoe)\n\nCompute the direction vector of the bound leg of a Horseshoe.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.bound_velocity-Tuple{Any, Horseshoe, Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.bound_velocity","text":"bound_velocity(r, hs :: Horseshoe, Γ, u_hat)\n\nCompute the induced velocity at a point r from the bound leg with constant strength Γ of a given Horseshoe.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.boundary_condition-Tuple{Any, Any, Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.boundary_condition","text":"boundary_condition(vortices, U, Ω)\n\nAssemble the boundary condition vector given an array of AbstractVortex, the freestream velocity U, and a quasi-steady rotation vector  Ω.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.center_of_pressure-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.center_of_pressure","text":"center_of_pressure(system :: VortexLatticeSystem)\n\nDetermine the center of pressure x_cp of the VortexLatticeSystem. \n\nThis is computed based on the nearfield lift C_L and moment Cₘ coefficients, and the reference location xᵣ and chord length cᵣ from References: x_cp = xᵣ -cᵣ(Cₘ  C_L)\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.farfield-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.farfield","text":"farfield(system :: VortexLatticeSystem)\n\nCompute the total farfield force coefficients of the VortexLatticeSystem. These are in wind axes by definition.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.farfield_coefficients-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.farfield_coefficients","text":"farfield_coefficients(system :: VortexLatticeSystem)\n\nCompute the total farfield force coefficients for all components of the VortexLatticeSystem. These are in wind axes by definition.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.farfield_forces-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.farfield_forces","text":"farfield_forces(system :: VortexLatticeSystem)\n\nCompute the farfield forces in wind axes for all components of the VortexLatticeSystem.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.freestream_derivatives-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.freestream_derivatives","text":"freestream_derivatives(\n    system :: VortexLatticeSystem,\n    name = :aircraft,\n    axes = Wind(),\n    print = false,\n    print_components = false,\n    farfield = false\n)\n\nObtain the force and moment coefficients of the components of a VortexLatticeSystem and their derivatives with respect to freestream values: Mach M (if compressible), angles of attack α and sideslip β, and non-dimensionalized rotation rates p q r (in stability axes).\n\nThe axes of the force and moment coefficients can be changed by passing any axis system (such as Body(), Geometry(), Wind(), Stability()) to the named axes argument. The force and moment coefficients are reported in wind axes by default. Note that the rotation rates will still refer to the rotation vector in stability axes.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.influence_matrix-Tuple{Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.influence_matrix","text":"influence_matrix(vortices)\ninfluence_matrix(vortices, u_hat)\n\nAssemble the Aerodynamic Influence Coefficient (AIC) matrix given an array of AbstractVortex and the freestream direction u.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.nearfield-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.nearfield","text":"nearfield(system :: VortexLatticeSystem)\n\nCompute the total nearfield force and moment coefficients for all components of the VortexLatticeSystem. These are in wind axes by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.nearfield_coefficients-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.nearfield_coefficients","text":"nearfield_coefficients(system :: VortexLatticeSystem)\n\nCompute the nearfield force and moment coefficients for all components of the VortexLatticeSystem. These are in wind axes by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.print_coefficients","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.print_coefficients","text":"print_coefficients(\n    system :: VortexLatticeSystem, \n    name = :aircraft;\n    components = false\n)\n\nPrint a pretty table of the total nearfield and farfield coefficients of a VortexLatticeSystem with an optional name.\n\nA named Boolean argument components is provided to also enable the printing of any possible components.\n\n\n\n\n\n","category":"function"},{"location":"aerodynamics/#AeroFuse.VortexLattice.print_coefficients-2","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.print_coefficients","text":"print_coefficients(\n    nf_coeffs, ff_coeffs, \n    name = \"\"\n)\n\nPrint a pretty table of the nearfield and farfield coefficients with an optional name.\n\n\n\n\n\n","category":"function"},{"location":"aerodynamics/#AeroFuse.VortexLattice.print_derivatives","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.print_derivatives","text":"print_derivatives(\n    nf_coeffs, ff_coeffs, name = \"\";\n    farfield = false,\n    axes = \"\"\n)\n\nPrint a pretty table of the aerodynamic coefficients and derivatives with an optional name and named arguments for enabling printing of farfield coefficients and the axis name.\n\n\n\n\n\n","category":"function"},{"location":"aerodynamics/#AeroFuse.VortexLattice.surface_dynamics-Tuple{Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.surface_dynamics","text":"surface_dynamics(\n    system :: VortexLatticeSystem; \n    axes :: AbstractAxisSystem = system.axes\n)\n\nCompute the forces and moments for all components of the VortexLatticeSystem in a specified reference axis system as a named argument.\n\nThe reference axis system is set to the axes defined in the construction of the VortexLatticeSystem by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.surface_forces-Tuple{Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.surface_forces","text":"surface_forces(\n    system :: VortexLatticeSystem; \n    axes :: AbstractAxisSystem = system.axes\n)\n\nCompute the forces for all components of the VortexLatticeSystem in a specified reference axis system as a named argument.\n\nThe reference axis system is set to the axes defined in the construction of the VortexLatticeSystem by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.surface_moments-Tuple{Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.surface_moments","text":"surface_moments(\n    system :: VortexLatticeSystem; \n    axes :: AbstractAxisSystem = system.axes\n)\n\nCompute the moments for all components of the VortexLatticeSystem in a specified reference axis system as a named argument.\n\nThe reference axis system is set to the axes defined in the construction of the VortexLatticeSystem by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.trailing_velocity-Tuple{Any, Horseshoe, Any, Any}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.trailing_velocity","text":"trailing_velocity(r, hs :: Horseshoes, Γ, u_hat)\n\nCompute the induced velocity at a point r from the semi-infinite trailing legs with constant strength Γ of a given Horseshoe hs.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.transform-Tuple{Horseshoe, CoordinateTransformations.LinearMap}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.transform","text":"transform(hs :: Horseshoe, T :: LinearMap)\n\nGenerate a new Horseshoe with the points and normal vectors transformed by the LinearMap T.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.VortexLattice.transform-Tuple{VortexRing, CoordinateTransformations.LinearMap}","page":"Aerodynamics API","title":"AeroFuse.VortexLattice.transform","text":"transform(ring :: VortexRing, T :: LinearMap)\n\nGenerate a new VortexRing with the points and normal vectors transformed by the LinearMap T.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.solve_linear-Tuple{Any, Any, Any}","page":"Aerodynamics API","title":"AeroFuse.solve_linear","text":"solve_linear(horseshoes, normals, U, Ω)\n\nEvaluate and return the vortex strengths Γs given an array of Horseshoes, their associated normal vectors, the velocity vector U, and the quasi-steady rotation vector Ω.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.surface_coefficients-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.surface_coefficients","text":"surface_coefficients(\n    system :: VortexLatticeSystem; \n    axes :: AbstractAxisSystem = system.axes\n)\n\nCompute the force and moment coefficients of the surfaces over all components in a given VortexLatticeSystem, in a specified reference axis system as a named argument.\n\nThe reference axis system is set to the axes defined in the construction of the VortexLatticeSystem by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.surface_velocities-Tuple{VortexLatticeSystem}","page":"Aerodynamics API","title":"AeroFuse.surface_velocities","text":"surface_velocities(\n    system :: VortexLatticeSystem; \n    axes :: AbstractAxisSystem = system.axes\n)\n\nCompute the induced velocities for all components of the VortexLatticeSystem in a specified reference axis system as a named argument.\n\nThe reference axis system is set to the axes defined in the construction of the VortexLatticeSystem by default.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/#AeroFuse.velocity","page":"Aerodynamics API","title":"AeroFuse.velocity","text":"velocity(r, hs :: Horseshoe, Γ, u_hat = [1.,0.,0.])\n\nCompute the induced velocity at a point r of a given Horseshoe with a bound leg of constant strength Γ and semi-infinite trailing legs pointing in a given direction û, by default û = x̂.\n\n\n\n\n\n","category":"function"},{"location":"aerodynamics/#AeroFuse.velocity-2","page":"Aerodynamics API","title":"AeroFuse.velocity","text":"velocity(r, ring :: VortexRing, Γ)\n\nComputes the velocity at a point r induced by a VortexRing with constant strength Γ.\n\n\n\n\n\n","category":"function"},{"location":"aerodynamics/#AeroFuse.velocity-Tuple{Freestream, Geometry}","page":"Aerodynamics API","title":"AeroFuse.velocity","text":"velocity(freestream :: Freestream, ::Geometry)\n\nCompute the velocity of Freestream in the geometry axis system.\n\n\n\n\n\n","category":"method"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"EditURL = \"https://github.com/GodotMisogi/AeroFuse.jl/blob/main/docs/lit/tutorials-airfoil.jl\"","category":"page"},{"location":"tutorials-airfoil/#Objectives","page":"Airfoil Aerodynamic Analysis","title":"Objectives","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Here we will show you how to perform an aerodynamic analysis of an airfoil.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"RecipeCompute the coordinates of a NACA 4-digit series airfoil.\nPlot its camber, thickness, upper and lower surface representations.\nPerform an aerodynamic analysis at a given angle of attack.\nPlot its aerodynamic properties.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"For this, we will need to import some packages which will be convenient for plotting.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"using AeroFuse      # Main package\nusing Plots         # Plotting library\ngr(dpi = 300)       # Plotting backend\nusing LaTeXStrings  # For LaTeX printing in plots","category":"page"},{"location":"tutorials-airfoil/#Your-First-Airfoil","page":"Airfoil Aerodynamic Analysis","title":"Your First Airfoil","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can define a NACA 4-digit series airfoil using the following function.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"airfoil = naca4((2,4,1,2), 60)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can access the x- and y-coordinates as the following fields.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"airfoil.x, airfoil.y","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can obtain the coordinates as an array by calling the following function.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"coordinates(airfoil)","category":"page"},{"location":"tutorials-airfoil/#Geometric-Representations","page":"Airfoil Aerodynamic Analysis","title":"Geometric Representations","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can convert these coordinates into the camber-thickness representation.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"xcamthick = camber_thickness(airfoil, 60)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can split the coordinates into their upper and lower surfaces.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"upper, lower = split_surface(airfoil);\n\nx_upper, y_upper = @views upper[:,1], upper[:,2]\nx_lower, y_lower = @views lower[:,1], lower[:,2];\nnothing #hide","category":"page"},{"location":"tutorials-airfoil/#Plotting","page":"Airfoil Aerodynamic Analysis","title":"Plotting","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can plot the airfoil by calling plot from Plots.jl and passing the Foil object as the first argument. Optionally, you can enable flags to plot the camber and thickness distributions.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"plot(\n    airfoil,\n    camber = true,\n    thickness = true,\n    aspect_ratio = 1,\n    xlabel=L\"(x/c)\",\n    ylabel = L\"y\"\n)","category":"page"},{"location":"tutorials-airfoil/#Your-First-Doublet-Source-Analysis","page":"Airfoil Aerodynamic Analysis","title":"Your First Doublet-Source Analysis","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Now we have an airfoil, and we would like to analyze its aerodynamic characteristics. The potential flow panel method for inviscid analyses of airfoils, which you may have studied in your course on aerodynamics, provides decent estimations of the lift generated by the airfoil.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Our analysis also requires boundary conditions, which is the freestream flow defined by a magnitude V_infty and angle of attack alpha. We provide these to the analysis by defining variables and feeding them to a Uniform2D type, corresponding to uniform flow in 2 dimensions.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"V       = 1.0\nalpha   = 4.0 # degrees\nuniform = Uniform2D(V, alpha)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can analyze this airfoil for the given freestream flow as shown.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"system  = solve_case(\n                     airfoil, uniform;\n                     num_panels = 80\n                    );\nnothing #hide","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"This will run the analysis and return a system which can be used to obtain the aerodynamic quantities of interest and post-processing. The panels used for the analysis can be accessed as follows.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"panels = system.surface_panels","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can compute the lift coefficient from the system.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"cl = lift_coefficient(system)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"You can also compute the sectional lift, moment and pressure coefficients.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"cls, cms, cps = surface_coefficients(system)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Note the difference between the lift coefficient computed and the sum of the sectional lift coefficients; this is due to numerical errors in the solution procedure and modeling.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"cl, sum(cls)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"info: Info\nSupport for drag prediction with boundary layer calculations will be added soon. For now, try out the amazing Webfoil developed by the MDOLab at University of Michigan – Ann Arbor!","category":"page"},{"location":"tutorials-airfoil/#Visualization","page":"Airfoil Aerodynamic Analysis","title":"Visualization","text":"","category":"section"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Let's see what the pressure and lift distribution curves look like over the airfoil. AeroFuse provides more helper functions for post-processing data. For example, you can make your fancy plots by segregating the values depending on the locations of the panels by defining the following function.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"cp_upper, cp_lower = get_surface_values(panels, cps)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Now let's plot the results!","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"# Pressure coefficients\nplot(yflip = true, xlabel = L\"(x/c)\", ylabel = L\"C_p\", lw = 2)\nplot!(cp_upper, label = L\"$C_p$ Upper\",\n      ls = :dash, lw = 2, c = :cornflowerblue)\nplot!(cp_lower, label = L\"$C_p$ Lower\",\n      ls = :dash, lw = 2, c = :orange)\nplot!(x_upper, -y_upper, label = \"$(airfoil.name) Upper\",\n      ls = :solid, lw = 2, c = :cornflowerblue)\nplot!(x_lower, -y_lower, label = \"$(airfoil.name) Lower\",\n      ls = :solid, lw = 2, c = :orange)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"# Lift coefficients\ncl_upper, cl_lower = get_surface_values(panels, cls)\n\ncl_plot = plot(xlabel = L\"(x/c)\", ylabel = L\"C_l\", lw = 2)\nplot!(cl_upper, label = L\"$C_l$ Upper\",\n      ls = :dash, lw = 2, c = :cornflowerblue)\nplot!(cl_lower, label = L\"$C_l$ Lower\",\n      ls = :dash, lw = 2, c = :orange)\nplot!(x_lower, y_lower, label = \"$(airfoil.name) Lower\",\n      ls = :solid, lw = 2, c = :orange)\nplot!(x_upper, y_upper, label = \"$(airfoil.name) Upper\",\n      ls = :solid, lw = 2, c = :cornflowerblue)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"# Moment coefficients\ncm_upper, cm_lower = get_surface_values(panels, cms)\n\ncm_plot = plot(xlabel = L\"(x/c)\", ylabel = L\"C_m\")\nplot!(cm_upper, label = L\"$C_m$ Upper\",\n      ls = :dash, lw = 2, c = :cornflowerblue)\nplot!(cm_lower, label = L\"$C_m$ Lower\",\n      ls = :dash, lw = 2, c = :orange)\nplot!(x_upper, y_upper, label = L\"$C_m$ Upper\",\n      ls = :solid, lw = 2, c = :cornflowerblue)\nplot!(x_lower, y_lower, label = L\"$C_m$ Lower\",\n      ls = :solid, lw = 2, c = :orange)","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"Great! We've created our first airfoil and run an aerodynamic analysis in 2 dimensions. Now we can move on to analyzing an aircraft configuration in the Aircraft Aerodynamic Analysis tutorial.","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"","category":"page"},{"location":"tutorials-airfoil/","page":"Airfoil Aerodynamic Analysis","title":"Airfoil Aerodynamic Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"development/#API","page":"In-Progress API","title":"API","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"EditURL = \"https://github.com/GodotMisogi/AeroFuse.jl/blob/main/docs/lit/tutorials-stability.jl\"","category":"page"},{"location":"tutorials-stability/#Objectives","page":"Aerodynamic Stability Analysis","title":"Objectives","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Here we will show you how to perform an aerodynamic stability analysis of a conventional aircraft. Here, we'll attempt to replicate the design of a Boeing 777. It won't be a realistic replication, but the overall geometry will match to a certain extent.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"(Image: ) Source: boeingboeing2, DeviantArt","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"note: Note\nRefer to the Aircraft Aerodynamic Analysis tutorial before studying this tutorial.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"RecipeDefine the geometries of a fuselage, wing, horizontal tail and vertical tail.\nPerform an aerodynamic analysis of this aircraft configuration at given freestream conditions and reference values.\nEvaluate the derivatives of the aerodynamic coefficients with respect to the freestream conditions.\nEvaluate the quantities of interest for aerodynamic stability.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Let's import the relevant packages.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"using AeroFuse          # Main package\nusing Plots             # Plotting library\ngr(                     # Plotting backend\n    size = (800,600),   # Size\n    dpi = 300,          # Resolution\n    palette = :Dark2_8  # Color scheme\n)\nusing LaTeXStrings      # For LaTeX printing in plots","category":"page"},{"location":"tutorials-stability/#Aircraft-Geometry","page":"Aerodynamic Stability Analysis","title":"Aircraft Geometry","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"First, let's define the fuselage. Here we'll define it by combining a cylindrical definition for the cabin with hyperelliptical curves for the nose and rear.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"# Fuselage definition\nfuse = HyperEllipseFuselage(\n    radius = 3.04,          # Radius, m\n    length = 63.7,          # Length, m\n    x_a    = 0.15,          # Start of cabin, ratio of length\n    x_b    = 0.7,           # End of cabin, ratio of length\n    c_nose = 2.0,           # Curvature of nose\n    c_rear = 1.2,           # Curvature of rear\n    d_nose = -0.5,          # \"Droop\" or \"rise\" of nose, m\n    d_rear = 1.0,           # \"Droop\" or \"rise\" of rear, m\n    position = [0.,0.,0.]   # Set nose at origin, m\n)\n\n# Compute geometric properties\nts = 0:0.1:1                # Distribution of sections for nose, cabin and rear\nS_f = wetted_area(fuse, ts) # Surface area, m²\nV_f = volume(fuse, ts)      # Volume, m³\n\n# Get coordinates of rear end\nfuse_end = fuse.affine.translation + [ fuse.length, 0., 0. ]","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Now, let's define the lifting surfaces. We'll download a supercritical airfoil for the wing section; note that this is not the same one as used in the Boeing 777-200LR. We'll also define a two-section wing.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"# Define one airfoil\nfoil_w = read_foil(download(\"http://airfoiltools.com/airfoil/seligdatfile?airfoil=rae2822-il\"))\n\n# Define vector of airfoils\nfoils = [ foil_w, foil_w, naca4((0,0,1,2)) ]\n\n# Wing\nwing = Wing(\n    foils       = foils,                        # Airfoils\n    chords      = [14.0, 9.73, 1.43561],        # Chord lengths\n    spans       = [14.0, 46.9] / 2,             # Span lengths\n    dihedrals   = fill(6, 2),                   # Dihedral angles (deg)\n    sweeps      = fill(35.6, 2),                # Sweep angles (deg )\n    w_sweep     = 0.,                           # Leading-edge sweep\n    position    = [19.51, 0., -2.5],            # Position\n    symmetry    = true                          # Symmetry\n)\n\nb_w = span(wing)\nS_w = projected_area(wing)\nc_w = mean_aerodynamic_chord(wing)\nx_w, y_w, z_w = mac_w = mean_aerodynamic_center(wing)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"For reference, let's plot what we have so far.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"p1 = plot(\n    xaxis = L\"x\", yaxis = L\"y\", zaxis = L\"z\",\n    aspect_ratio = 1,\n    zlim = (-0.5, 0.5) .* span(wing),\n    camera = (30,30)\n)\n\nplot!(fuse, label = \"Fuselage\", alpha = 0.6)\nplot!(wing, label = \"Wing\")","category":"page"},{"location":"tutorials-stability/#Stabilizers","page":"Aerodynamic Stability Analysis","title":"Stabilizers","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Now, let's add the stabilizers. First, the horizontal tail.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"htail = WingSection(\n    area        = 101,  # Area (m²)\n    aspect      = 4.2,  # Aspect ratio\n    taper       = 0.4,  # Taper ratio\n    dihedral    = 7.,   # Dihedral angle (deg)\n    sweep       = 35.,  # Sweep angle (deg)\n    w_sweep     = 0.,   # Leading-edge sweep\n    root_foil   = naca4(0,0,1,2),\n    symmetry    = true,\n\n    # Orientation\n    angle       = -2,           # Incidence angle (deg)\n    axis        = [0., 1., 0.], # Axis of rotation, y-axis\n    position    = [ fuse_end.x - 8., 0., 0.],\n)\n\nb_h = span(htail)\nS_h = projected_area(htail)\nc_h = mean_aerodynamic_chord(htail)\nx_h, y_h, z_h = mac_h = mean_aerodynamic_center(htail)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Now the vertical tail.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"vtail = WingSection(\n    area        = 56.1, # Area (m²)\n    aspect      = 1.5,  # Aspect ratio\n    taper       = 0.4,  # Taper ratio\n    sweep       = 44.4, # Sweep angle (deg)\n    w_sweep     = 0.,   # Leading-edge sweep\n    root_foil   = naca4(0,0,0,9),\n\n    # Orientation\n    angle       = 90.,       # To make it vertical\n    axis        = [1, 0, 0], # Axis of rotation, x-axis\n    position    = htail.affine.translation - [2.,0.,0.]\n) # Not a symmetric surface\n\nb_v = span(vtail)\nS_v = projected_area(vtail)\nc_v = mean_aerodynamic_chord(vtail)\nx_v, y_v, z_v = mac_v = mean_aerodynamic_center(vtail)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Let's mesh and plot the lifting surfaces.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"wing_mesh = WingMesh(wing, [8,16], 10,\n    span_spacing = fill(Uniform(), 4) # Number of spacings = number of spanwise stations\n    # (including symmetry)\n)\n\nhtail_mesh = WingMesh(htail, [10], 8)\nvtail_mesh = WingMesh(vtail, [8], 6)\n\n# Plot meshes\nplt = plot(\n    xaxis = L\"x\", yaxis = L\"y\", zaxis = L\"z\",\n    aspect_ratio = 1,\n    zlim = (-0.5, 0.5) .* span(wing_mesh),\n    camera = (30, 45),\n)\nplot!(fuse, label = \"Fuselage\", alpha = 0.6)\nplot!(plt, wing_mesh, label = \"Wing\")\nplot!(plt, htail_mesh, label = \"Horizontal Tail\")\nplot!(plt, vtail_mesh, label = \"Vertical Tail\")","category":"page"},{"location":"tutorials-stability/#Aerodynamic-Analysis","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Analysis","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Now, let's generate the horseshoe system for the aircraft.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"aircraft = ComponentVector(\n    wing  = make_horseshoes(wing_mesh),\n    htail = make_horseshoes(htail_mesh),\n    vtail = make_horseshoes(vtail_mesh)\n)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"warning: Alert!\nNote that the fuselage is not included in the analysis for now, and is only included for plotting. Support for its aerodynamic analysis will be added soon.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Now, let's define the freestream conditions.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"fs  = Freestream(\n    alpha = 3.0, # degrees\n    beta  = 0.0, # degrees\n    omega = [0., 0., 0.]\n);\nnothing #hide","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Similarly, define the reference values. Here, the reference flight condition will be set to Mach number M = 084.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"M = 0.84 # Mach number\nrefs = References(\n    speed    = M * 330.,\n    density  = 1.225,\n    span     = b_w,\n    area     = S_w,\n    chord    = c_w,\n    location = mac_w\n);\nnothing #hide","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Let's run the aerodynamic analysis first.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"system = solve_case(\n    aircraft, fs, refs;\n    compressible     = true, # Compressibility option\n    # print            = true, # Prints the results for only the aircraft\n    # print_components = true, # Prints the results for all components\n)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"info: Info\nYou may receive a warning that the results are incorrect; this is due to the limitation of the vortex lattice method being able to primarily analyze only subsonic flows under the physical assumptions.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"The freestream derivatives can be obtained by passing the resultant system as follows:","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"dvs = freestream_derivatives(\n    system,                     # VortexLatticeSystem\n    axes             = Wind(),  # Specify axis system for nearfield forces (wind by default)\n    # print            = true,    # Prints the results for only the aircraft\n    # print_components = true,    # Prints the results for all components\n    # farfield         = true,    # Print farfield derivatives\n);\nnothing #hide","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"You can access the derivatives of each lifting surface based on the keys defined in the ComponentVector.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"ac_dvs = dvs.aircraft","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"These quantities are the force and moment coefficients (C_X C_Y C_Z C_l C_m C_n C_D_iff C_Y_ff C_L_ff) generated from the nearfield and farfield analyses, and their derivatives respect to the Mach number M, freestream angles of attack and sideslip (alpha beta), and the non-dimensional angular velocity rates (barp barq barr). The keys corresponding to the freestream derivatives should be evident:","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"keys(dvs.aircraft)","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"These can be accessed either like a dictionary, or by 'dot' syntax.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"ac_dvs[:CZ_al], ac_dvs.CZ_al, ac_dvs.CLff_al # Lift coefficient derivative wrt. alpha","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Note that the nearfield forces and moments (C_X C_Y C_Z C_l C_m C_n) depend on the axis system used (C_Z is not lift if body axes are used!). You can also pretty-print the derivatives for each surface.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"print_derivatives(dvs.aircraft, \"Aircraft\", farfield = true)\nprint_derivatives(dvs.wing, \"Wing\", farfield = true)\nprint_derivatives(dvs.htail, \"Horizontal Tail\", farfield = true)\nprint_derivatives(dvs.vtail, \"Vertical Tail\", farfield = true)","category":"page"},{"location":"tutorials-stability/#Static-Stability-Analysis","page":"Aerodynamic Stability Analysis","title":"Static Stability Analysis","text":"","category":"section"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"You can evaluate the static stability of the aircraft using the various quantities computed in this process, following standard computations and definitions in aircraft design and stability analysis.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"l_h = x_h - x_w                 # Horizontal tail moment arm\nV_h = S_h / S_w * l_h / c_w     # Horizontal tail volume coefficient\n\nl_v = x_v - x_w                 # Vertical tail moment arm\nV_v = S_v / S_w * l_v / b_w     # Vertical tail volume coefficient\n\nx_cp = -refs.chord * ac_dvs.Cm / ac_dvs.CZ # Center of pressure\n\nx_np_lon = -refs.chord * ac_dvs.Cm_al / ac_dvs.CZ_al # Neutral point\n\n# Position vectors\nx_np, y_np, z_np = r_np = refs.location + [ x_np_lon; zeros(2) ]  # Neutral point\nx_cp, y_cp, z_cp = r_cp = refs.location + [ x_cp; zeros(2) ]  # Center of pressure\n\n@info \"Horizontal TVC                V_h:\" V_h\n@info \"Vertical TVC                  V_v:\" V_v\n@info \"Wing Aerodynamic Center  x_ac (m):\" x_w\n@info \"Neutral Point            x_np (m):\" x_np\n@info \"Center of Pressure       x_cp (m):\" x_cp","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"Let's plot the relevant quantities.","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"stab_plt = plot(\n    xaxis = L\"x\", yaxis = L\"y\", zaxis = L\"z\",\n    aspect_ratio = 1,\n    zlim = (-0.5, 0.5) .* span(wing_mesh),\n    camera = (0,90),\n)\nplot!(fuse, label = \"Fuselage\", alpha = 0.6)\nplot!(stab_plt, wing_mesh, label = \"Wing\", mac = false)\nplot!(stab_plt, htail_mesh, label = \"Horizontal Tail\", mac = false)\nplot!(stab_plt, vtail_mesh, label = \"Vertical Tail\", mac = false)\n\nscatter!(Tuple(r_np), color = :orange, label = \"Neutral Point\")\nscatter!(Tuple(r_cp), color = :brown, label = \"Center of Pressure\")","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"","category":"page"},{"location":"tutorials-stability/","page":"Aerodynamic Stability Analysis","title":"Aerodynamic Stability Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"EditURL = \"https://github.com/GodotMisogi/AeroFuse.jl/blob/main/docs/lit/tutorials-aircraft.jl\"","category":"page"},{"location":"tutorials-aircraft/#Objectives","page":"Aircraft Aerodynamic Analysis","title":"Objectives","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Here we will show you how to perform an aerodynamic analysis of a conventional aircraft.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"RecipeDefine the geometries of a wing, horizontal tail and vertical tail.\nMesh and plot the geometries for numerical analyses.\nPerform an aerodynamic analysis of this aircraft configuration at given freestream conditions and reference values.\nEvaluate its drag polar for a given range of angles of attack.\nPlot the spanwise loading distribution for the wing.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"For this, we will need to import some packages which will be convenient for plotting.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"using AeroFuse          # Main package\nusing Plots             # Plotting library\ngr(                     # Plotting backend\n    size = (800,600),   # Size\n    dpi = 300,          # Resolution\n    palette = :Dark2_8  # Color scheme\n)\nusing LaTeXStrings      # For LaTeX printing in plots","category":"page"},{"location":"tutorials-aircraft/#Your-First-Wing","page":"Aircraft Aerodynamic Analysis","title":"Your First Wing","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Here you will learn how to define a wing using an intuitive parametrization scheme. First, we define a Vector of Foils.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Define one airfoil\nairfoil_1 = naca4(4,4,1,2)\n\n# Define vector of airfoils\nairfoils  = [ airfoil_1, naca4((0,0,1,2)) ]","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"note: Note\nRefer to the Airfoil Aerodynamic Analysis tutorial for an introduction to the Foil type.","category":"page"},{"location":"tutorials-aircraft/#Parametrization","page":"Aircraft Aerodynamic Analysis","title":"Parametrization","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"The following function defines a symmetric, single-section wing and prints the relevant information.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"note: Note\nAll relevant units are presented in metric.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"wing = Wing(\n    foils     = airfoils,    # Foil profiles\n    chords    = [1.0, 0.6],  # Chord lengths\n    twists    = [2.0, 0.0],  # Twist angles (degrees)\n    spans     = [4.0],       # Section span lengths\n    dihedrals = [5.],        # Dihedral angles (degrees)\n    sweeps    = [5.],        # Sweep angles (degrees)\n    w_sweep   = 0.,          # Sweep angle location w.r.t.\n                             # normalized chord lengths ∈ [0,1]\n    symmetry  = true,        # Whether wing is symmetric\n    # flip      = false      # Whether wing is reflected\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"In this case, the root chord is 10m and the tip chord is 06m, and so on.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"info: Info\nSee the How-to Guide for the various ways of constructing wings.","category":"page"},{"location":"tutorials-aircraft/#Visualization","page":"Aircraft Aerodynamic Analysis","title":"Visualization","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can plot the lifting surface by calling plot with Plots.jl.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"plt = plot(\n    xlabel = L\"x\", ylabel = L\"y\", zlabel = L\"z\",\n    aspect_ratio = 1,\n    camera = (30, 30),\n    zlim = (-0.5, 0.5) .* span(wing),\n)\n\nplot!(plt, wing, label = \"Wing\")","category":"page"},{"location":"tutorials-aircraft/#Your-First-Vortex-Lattice-Analysis","page":"Aircraft Aerodynamic Analysis","title":"Your First Vortex Lattice Analysis","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Now we would like to analyze the aerodynamics of this wing in conjunction with other lifting surfaces pertinent to aircraft.","category":"page"},{"location":"tutorials-aircraft/#Geometry","page":"Aircraft Aerodynamic Analysis","title":"Geometry","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"We define the horizontal tail similarly to the wing. However, we also add additional position (by specifying a vector) and orientation attributes (by specifying an angle and axis of rotation) to place it at the desired location.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Horizontal tail\nhtail = Wing(\n    foils     = fill(naca4(0,0,1,2), 2),\n    chords    = [0.7, 0.42],\n    twists    = [0.0, 0.0],\n    spans     = [1.25],\n    dihedrals = [0.],\n    sweeps    = [6.39],\n    w_sweep   = 0.,\n    position  = [4., 0, 0],\n    angle     = -2.,\n    axis      = [0., 1., 0.],\n    symmetry  = true\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"For the vertical tail, we simply set symmetry = false to define its shape.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Vertical tail\nvtail = Wing(\n    foils     = fill(naca4(0,0,0,9), 2),\n    chords    = [0.7, 0.42],\n    twists    = [0.0, 0.0],\n    spans     = [1.0],\n    dihedrals = [0.],\n    sweeps    = [7.97],\n    w_sweep   = 0.,\n    position  = [4., 0, 0],\n    angle     = 90.,\n    axis      = [1., 0., 0.]\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Let's visualize the geometry of the aircraft's configuration.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"plot!(plt, htail, label = \"Horizontal Tail\")\nplot!(plt, vtail, label = \"Vertical Tail\")","category":"page"},{"location":"tutorials-aircraft/#Meshing","page":"Aircraft Aerodynamic Analysis","title":"Meshing","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"To perform the aerodynamic analysis, we will need to discretize our geometry into a mesh. The following WingMesh function constructs a mesh for you by providing a HalfWing or Wing type with specification of spanwise panels and chordwise panels. As the wing has only one spanwise section, we provide a vector with a single  integer entry for the spanwise panel distribution.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"wing_mesh = WingMesh(wing, [20], 12) # (Wing, [Spanwise panels], Chordwise panels)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Let's see what this discretization looks like on the camber distribution of the wing.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Compute camber panel distribution\nplot!(plt, wing_mesh, label = \"\")","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Similarly we define the meshes for the other surfaces and plot them.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"htail_mesh = WingMesh(htail, [8], 6)\nvtail_mesh = WingMesh(vtail, [6], 4)\n\nplot!(plt, htail_mesh, label = \"\")\nplot!(plt, vtail_mesh, label = \"\")","category":"page"},{"location":"tutorials-aircraft/#Aerodynamic-Analysis","page":"Aircraft Aerodynamic Analysis","title":"Aerodynamic Analysis","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"For the analysis, we need to generate a Horseshoe type, corresponding to horseshoe singularity elements used in the vortex lattice method. This is generated as follows:","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"make_horseshoes(wing_mesh)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"To perform the aerodynamic analysis, you have to assemble these horseshoes for each surface into a ComponentVector.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"aircraft = ComponentVector(\n    wing  = make_horseshoes(wing_mesh),\n    htail = make_horseshoes(htail_mesh),\n    vtail = make_horseshoes(vtail_mesh)\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can define the freestream condition as follows, by providing the angles of attack alpha and sideslip beta in degrees with a rotation vector Omega.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"fs  = Freestream(\n    alpha = 3.0, # degrees\n    beta  = 0.0, # degrees\n    omega = [0., 0., 0.]\n);\nnothing #hide","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can define the reference values for the speed, area, span, chord, density, and location  as follows.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"refs = References(\n    speed    = 1.0,\n    area     = projected_area(wing),\n    span     = span(wing),\n    chord    = mean_aerodynamic_chord(wing),\n    density  = 1.225,\n    location = mean_aerodynamic_center(wing)\n);\nnothing #hide","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can run the aerodynamic analysis by providing the aircraft configuration, freestream, and reference values. Optionally you can also print the results.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"system = solve_case(\n    aircraft, fs, refs;\n    compressible     = false, # Compressibility option\n    # print            = true, # Prints the results for only the aircraft\n    # print_components = true, # Prints the results for all components\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can obtain the aerodynamic coefficients from this system. The nearfield aerodynamic force and moment coefficients are ordered as (C_D_i C_Y C_L C_ell C_m C_n).","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"nf = nearfield(system)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"The force coefficients are printed as (C_X C_Y C_Z) for general axis systems; wind axes are used in the nearfield function.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"tip: Tip\nRefer to the how-to guide to see how to compute the aerodynamic coefficients of each component and perform stability analyses.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"A convenience method is also provided for plotting streamlines from the leading edge of each surface.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"plot!(plt,\n    system,     # VortexLattice System\n    wing_mesh,  # Lifting surface (or mesh)\n    span = 4,   # Number of streamlines per spanwise section\n    dist = 10,  # Distance of streamlines (m)\n    # lc = :green, # Color of streamlines\n)\n\nplot!(plt, system, htail_mesh, span = 3, lc = :cyan) # For horizontal tail\nplot!(plt, system, vtail, span = 2, lc = :cyan) # For vertical tail","category":"page"},{"location":"tutorials-aircraft/#Drag-Polar","page":"Aircraft Aerodynamic Analysis","title":"Drag Polar","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Now let's analyze the drag polar of this aircraft configuration by varying the angle of attack and collecting the induced drag coefficient C_D_i.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Define function to compute system varying with angle of attack.\nvary_alpha(aircraft, α, refs) = VortexLatticeSystem(aircraft, Freestream(alpha = α), refs)\n\n# Run loop\nαs      = -5:0.5:5\nsystems = [ vary_alpha(aircraft, α, refs) for α in αs ]\n# Cleaner: map(α -> vary_alpha(...), αs)\n\n# Get coefficients\ncoeffs = nearfield.(systems)\nCDis   = [ c[1] for c in coeffs ]\nCLs    = [ c[3] for c in coeffs ];\nnothing #hide","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Let's plot the drag polar!","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"plot(CDis, CLs,\n     label  = \"\",\n     xlabel = L\"C_{D_i}\",\n     ylabel = L\"C_L\",\n     title  = \"Drag Polar\",\n     ls     = :solid)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Let's also take a look at the variations of all the coefficients.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"# Concatenate results into one array\ndata = permutedims(\n    mapreduce(hcat, systems) do sys\n        [sys.freestream.alpha; nearfield(sys) ]\n    end\n)\n\n# Plot\nplot(\n    data[:,1],  # Angle of attack\n    round.(data[:,2:end], digits = 4), # Aerodynamic coefficients\n    layout = (3,2),\n    xlabel = L\"\\alpha\",\n    ylabel = [L\"C_{D_i}\" L\"C_Y\" L\"C_L\" L\"C_\\ell\" L\"C_m\" L\"C_n\"],\n    labels = \"\",\n)","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"Tip: You can convert this into a DataFrame for convenient reference.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"using DataFrames\ndf = DataFrame(round.(data, digits = 6), [:α, :CX, :CY, :CZ, :Cl, :Cm, :Cn])","category":"page"},{"location":"tutorials-aircraft/#Spanwise-Loading","page":"Aircraft Aerodynamic Analysis","title":"Spanwise Loading","text":"","category":"section"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"You can compute the aerodynamic coefficients on the panels from the system.","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"CFs, CMs = surface_coefficients(system)\n\n# Compute spanwise loads\nspan_loads = spanwise_loading(wing_mesh, system.reference, CFs.wing, system.circulations.wing)\n\n# Plot spanwise loadings\nplot_CD = plot(span_loads[:,1], span_loads[:,2], label = :none, ylabel = L\"C_{D_i}\")\nplot_CY = plot(span_loads[:,1], span_loads[:,3], label = :none, ylabel = L\"C_Y\")\nplot_CL = begin\n            plot(span_loads[:,1], span_loads[:,4], label = :none, xlabel = L\"y\", ylabel = L\"C_L\")\n            plot!(span_loads[:,1], span_loads[:,5], label = L\"Γ/ρVc\", xlabel = L\"y\")\n        end\nplot(plot_CD, plot_CY, plot_CL, size = (800, 700), layout = (3,1))","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"","category":"page"},{"location":"tutorials-aircraft/","page":"Aircraft Aerodynamic Analysis","title":"Aircraft Aerodynamic Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AeroFuse-–-Aircraft-Design-Platform","page":"Home","title":"AeroFuse – Aircraft Design Platform","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AeroFuse is meant to be a toolbox for aircraft design analyses. It currently provides convenient methods for developing studies in aircraft geometry, aerodynamics and structures, with implementations in other relevant fields such as flight dynamics and propulsion in progress.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authors: Arjit Seth and Rhea P. Liem","category":"page"},{"location":"#Objectives","page":"Home","title":"Objectives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The current focus is to enable tutorials in computation in an aerospace educational curriculum, particularly at The Hong Kong University of Science and Technology. An additional aim is to write code compatible with automatic differentiation libraries written in Julia for enabling multidisciplinary studies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Disclaimer: The implementations are work-in-progress, and hence the results may not be entirely accurate. Please exercise caution when interpreting the results until validation cases are added.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Functioning:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic geometric tools for airfoil processing, wing (and tail), and fuselage design. \nSteady, inviscid, incompressible, isentropic 2D and 3D aerodynamic analyses.\n2D - Doublet-source panel method\n3D - Vortex lattice method\nSemi-/empirical profile drag prediction methods for wings.\nFinite-element beam model based on Euler-Bernoulli theory for structural analysis.\nAutomatic differentiation support primarily via ForwardDiff.jl.\nOptimization capabilities with these features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aerodynamic Analysis:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stability Analysis:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optimization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"In progress:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aeroelastic analyses coupling vortex lattice and beam element models. This is functioning, but a good interface is yet to be implemented.\nAdjoints for aerodynamic, structural and aerostructural design via ChainRulesCore.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please install the current stable release of Julia for your operating system and execute the following commands in the REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"AeroFuse\")\njulia> Pkg.test(\"AeroFuse\")\njulia> using AeroFuse","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use AeroFuse in your research, please cite the following until any relevant material is actually published:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{AeroFuse,\n  author  = {Arjit Seth, Rhea P. Liem},\n  title   = {AeroFuse},\n  url     = {https://github.com/GodotMisogi/AeroFuse},\n  version = {0.4.9},\n  date    = {2023-03-27},\n}","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"geometry.md\", \"aerodynamics.md\", \"structures.md\", \"theory.md\", \"api.md\"]\nDepth =  5","category":"page"}]
}
